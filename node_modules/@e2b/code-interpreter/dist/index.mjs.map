{"version":3,"sources":["../src/index.ts","../src/sandbox.ts","../src/messaging.ts","../src/utils.ts","../src/consts.ts"],"sourcesContent":["export * from 'e2b'\n\nexport { Sandbox } from './sandbox'\nexport type { Context, RunCodeOpts, CreateCodeContextOpts } from './sandbox'\nexport type {\n  Logs,\n  ExecutionError,\n  Result,\n  Execution,\n  MIMEType,\n  RawData,\n  OutputMessage,\n} from './messaging'\nexport type {\n  ScaleType,\n  ChartType,\n  ChartTypes,\n  Chart,\n  BarChart,\n  BarData,\n  LineChart,\n  ScatterChart,\n  BoxAndWhiskerChart,\n  BoxAndWhiskerData,\n  PieChart,\n  PieData,\n  SuperChart,\n  PointData,\n} from './charts'\nimport { Sandbox } from './sandbox'\n\nexport default Sandbox\n","import { Sandbox as BaseSandbox, InvalidArgumentError } from 'e2b'\n\nimport { Result, Execution, OutputMessage, parseOutput, extractError, ExecutionError } from './messaging'\nimport { formatExecutionTimeoutError, formatRequestTimeoutError, readLines } from \"./utils\";\nimport { JUPYTER_PORT, DEFAULT_TIMEOUT_MS } from './consts'\n\n/**\n * Represents a context for code execution.\n */\nexport type Context = {\n  /**\n   * The ID of the context.\n   */\n  id: string\n  /**\n   * The language of the context.\n   */\n  language: string\n  /**\n   * The working directory of the context.\n   */\n  cwd: string\n}\n\n/**\n * Options for running code.\n */\nexport interface RunCodeOpts {\n  /**\n   * Callback for handling stdout messages.\n   */\n  onStdout?: (output: OutputMessage) => (Promise<any> | any),\n  /**\n   * Callback for handling stderr messages.\n   */\n  onStderr?: (output: OutputMessage) => (Promise<any> | any),\n  /**\n   * Callback for handling the final execution result.\n   */\n  onResult?: (data: Result) => (Promise<any> | any),\n  /**\n   * Callback for handling the `ExecutionError` object.\n   */\n  onError?: (error: ExecutionError) => (Promise<any> | any),\n  /**\n   * Custom environment variables for code execution.\n   * \n   * @default {}\n   */\n  envs?: Record<string, string>,\n  /**\n   * Timeout for the code execution in **milliseconds**.\n   * \n   * @default 60_000 // 60 seconds\n   */\n  timeoutMs?: number,\n  /**\n   * Timeout for the request in **milliseconds**.\n   * \n   * @default 30_000 // 30 seconds\n   */\n  requestTimeoutMs?: number,\n}\n\n/**\n * Options for creating a code context.\n */\nexport interface CreateCodeContextOpts {\n  /**\n   * Working directory for the context.\n   * \n   * @default /home/user\n   */\n  cwd?: string,\n  /**\n   * Language for the context.\n   * \n   * @default python\n   */\n  language?: string,\n  /**\n   * Timeout for the request in **milliseconds**.\n   * \n   * @default 30_000 // 30 seconds\n   */\n  requestTimeoutMs?: number,\n}\n\n/**\n * E2B cloud sandbox is a secure and isolated cloud environment.\n *\n * The sandbox allows you to:\n * - Access Linux OS\n * - Create, list, and delete files and directories\n * - Run commands\n * - Run isolated code\n * - Access the internet\n *\n * Check docs [here](https://e2b.dev/docs).\n *\n * Use {@link Sandbox.create} to create a new sandbox.\n *\n * @example\n * ```ts\n * import { Sandbox } from '@e2b/code-interpreter'\n *\n * const sandbox = await Sandbox.create()\n * ```\n */\nexport class Sandbox extends BaseSandbox {\n  protected static override readonly defaultTemplate: string = 'code-interpreter-v1'\n\n  /**\n   * Run the code as Python.\n   * \n   * Specify the `language` or `context` option to run the code as a different language or in a different `Context`.\n   * \n   * You can reference previously defined variables, imports, and functions in the code.\n   *\n   * @param code code to execute.\n   * @param opts options for executing the code.\n   * \n   * @returns `Execution` result object.\n   */\n  async runCode(\n    code: string,\n    opts?: RunCodeOpts & {\n      /**\n       * Language to use for code execution.\n       * \n       * If not defined, the default Python context is used.\n       */\n      language?: 'python',\n    },\n  ): Promise<Execution>\n  /**\n   * Run the code for the specified language.\n   * \n   * Specify the `language` or `context` option to run the code as a different language or in a different `Context`.\n   * If no language is specified, Python is used.\n   * \n   * You can reference previously defined variables, imports, and functions in the code.\n   *\n   * @param code code to execute.\n   * @param opts options for executing the code.\n   * \n   * @returns `Execution` result object.\n   */\n  async runCode(\n    code: string,\n    opts?: RunCodeOpts & {\n      /**\n       * Language to use for code execution.\n       * \n       * If not defined, the default Python context is used.\n       */\n      language?: string,\n    },\n  ): Promise<Execution>\n  /**\n   * Runs the code in the specified context, if not specified, the default context is used.\n   * \n   * Specify the `language` or `context` option to run the code as a different language or in a different `Context`.\n   * \n   * You can reference previously defined variables, imports, and functions in the code.\n   *\n   * @param code code to execute.\n   * @param opts options for executing the code\n   * \n   * @returns `Execution` result object\n   */\n  async runCode(\n    code: string,\n    opts?: RunCodeOpts & {\n      /**\n       * Context to run the code in.\n       */\n      context?: Context,\n    },\n  ): Promise<Execution>\n  async runCode(\n    code: string,\n    opts?: RunCodeOpts & {\n      language?: string,\n      context?: Context,\n    },\n  ): Promise<Execution> {\n    if (opts?.context && opts?.language) {\n      throw new InvalidArgumentError(\"You can provide context or language, but not both at the same time.\")\n    }\n\n    const controller = new AbortController()\n\n    const requestTimeout = opts?.requestTimeoutMs ?? this.connectionConfig.requestTimeoutMs\n\n    const reqTimer = requestTimeout ? setTimeout(() => {\n      controller.abort()\n    }, requestTimeout)\n      : undefined\n\n    try {\n      const res = await fetch(`${this.jupyterUrl}/execute`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          code,\n          context_id: opts?.context?.id,\n          language: opts?.language,\n          env_vars: opts?.envs,\n        }),\n        signal: controller.signal,\n        keepalive: true,\n      })\n\n      const error = await extractError(res)\n      if (error) {\n        throw error\n      }\n\n      if (!res.body) {\n        throw new Error(`Not response body: ${res.statusText} ${await res?.text()}`)\n      }\n\n      clearTimeout(reqTimer)\n\n      const bodyTimeout = opts?.timeoutMs ?? DEFAULT_TIMEOUT_MS\n\n      const bodyTimer = bodyTimeout\n        ? setTimeout(() => {\n          controller.abort()\n        }, bodyTimeout)\n        : undefined\n\n      const execution = new Execution()\n\n\n      try {\n        for await (const chunk of readLines(res.body)) {\n          await parseOutput(execution, chunk, opts?.onStdout, opts?.onStderr, opts?.onResult, opts?.onError)\n        }\n      } catch (error) {\n        throw formatExecutionTimeoutError(error)\n      } finally {\n        clearTimeout(bodyTimer)\n      }\n\n      return execution\n    } catch (error) {\n      throw formatRequestTimeoutError(error)\n    }\n  }\n\n  /**\n   * Creates a new context to run code in.\n   *\n   * @param opts options for creating the context.\n   * \n   * @returns context object.\n   */\n  async createCodeContext(opts?: CreateCodeContextOpts): Promise<Context> {\n    try {\n      const res = await fetch(`${this.jupyterUrl}/contexts`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          language: opts?.language,\n          cwd: opts?.cwd,\n        }),\n        keepalive: true,\n        signal: this.connectionConfig.getSignal(opts?.requestTimeoutMs),\n      })\n\n      const error = await extractError(res)\n      if (error) {\n        throw error\n      }\n\n      return await res.json()\n    } catch (error) {\n      throw formatRequestTimeoutError(error)\n    }\n  }\n\n  protected get jupyterUrl(): string {\n    return `${this.connectionConfig.debug ? 'http' : 'https'}://${this.getHost(JUPYTER_PORT)}`\n  }\n}\n","import { NotFoundError, SandboxError, TimeoutError } from 'e2b'\nimport { ChartTypes } from './charts'\n\nexport async function extractError(res: Response) {\n  if (res.ok) {\n    return\n  }\n\n  switch (res.status) {\n    case 502:\n      return new TimeoutError(\n        `${await res.text()}: This error is likely due to sandbox timeout. You can modify the sandbox timeout by passing 'timeoutMs' when starting the sandbox or calling '.setTimeout' on the sandbox with the desired timeout.`\n      )\n    case 404:\n      return new NotFoundError(await res.text())\n    default:\n      return new SandboxError(`${res.status} ${res.statusText}`)\n  }\n}\n\n/**\n * Represents an output message from the sandbox code execution.\n */\nexport class OutputMessage {\n  constructor(\n    /**\n     * The output line.\n     */\n    public readonly line: string,\n    /**\n     * Unix epoch in nanoseconds.\n     */\n    public readonly timestamp: number,\n    /**\n     * Whether the output is an error.\n     */\n    public readonly error: boolean\n  ) { }\n\n  public toString() {\n    return this.line\n  }\n}\n\n/**\n * Represents an error that occurred during the execution of a cell.\n * The error contains the name of the error, the value of the error, and the traceback.\n */\nexport class ExecutionError {\n  constructor(\n    /**\n     * Name of the error.\n     **/\n    public name: string,\n    /**\n     * Value of the error.\n     **/\n    public value: string,\n    /**\n     * The raw traceback of the error.\n     **/\n    public traceback: string\n  ) { }\n}\n\n/**\n * Represents a MIME type.\n */\nexport type MIMEType = string\n\n\ntype E2BData = {\n  data: Record<string, unknown>\n  chart: ChartTypes\n}\n\n/**\n * Dictionary that maps MIME types to their corresponding representations of the data.\n */\nexport type RawData = {\n  [key: MIMEType]: string\n} & E2BData\n\n/**\n * Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.\n * The result is similar to the structure returned by ipython kernel: https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics\n *\n *\n * The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented\n * as a string, and the result can contain multiple types of data. The display calls don't have to have text representation,\n * for the actual result the representation is always present for the result, the other representations are always optional.\n */\nexport class Result {\n  /**\n   * Text representation of the result.\n   */\n  readonly text?: string\n  /**\n   * HTML representation of the data.\n   */\n  readonly html?: string\n  /**\n   * Markdown representation of the data.\n   */\n  readonly markdown?: string\n  /**\n   * SVG representation of the data.\n   */\n  readonly svg?: string\n  /**\n   * PNG representation of the data.\n   */\n  readonly png?: string\n  /**\n   * JPEG representation of the data.\n   */\n  readonly jpeg?: string\n  /**\n   * PDF representation of the data.\n   */\n  readonly pdf?: string\n  /**\n   * LaTeX representation of the data.\n   */\n  readonly latex?: string\n  /**\n   * JSON representation of the data.\n   */\n  readonly json?: string\n  /**\n   * JavaScript representation of the data.\n   */\n  readonly javascript?: string\n  /**\n   * Contains the data from DataFrame.\n   */\n  readonly data?: Record<string, unknown>\n  /**\n   * Contains the chart data.\n   */\n  readonly chart?: ChartTypes\n  /**\n   * Extra data that can be included. Not part of the standard types.\n   */\n  readonly extra?: any\n\n  readonly raw: RawData\n\n  constructor(rawData: RawData, public readonly isMainResult: boolean) {\n    const data = { ...rawData }\n    delete data['type']\n    delete data['is_main_result']\n\n    this.text = data['text']\n    this.html = data['html']\n    this.markdown = data['markdown']\n    this.svg = data['svg']\n    this.png = data['png']\n    this.jpeg = data['jpeg']\n    this.pdf = data['pdf']\n    this.latex = data['latex']\n    this.json = data['json']\n    this.javascript = data['javascript']\n    this.isMainResult = isMainResult\n    this.raw = data\n\n    this.data = data['data']\n    this.chart = data['chart']\n\n    this.extra = {}\n\n    for (const key of Object.keys(data)) {\n      if (\n        ![\n          'plain',\n          'html',\n          'markdown',\n          'svg',\n          'png',\n          'jpeg',\n          'pdf',\n          'latex',\n          'json',\n          'javascript',\n          'data',\n          'chart',\n          'extra',\n          \"text\"\n        ].includes(key)\n      ) {\n        this.extra[key] = data[key]\n      }\n    }\n  }\n\n  /**\n   * Returns all the formats available for the result.\n   *\n   * @returns Array of strings representing the formats available for the result.\n   */\n  formats(): string[] {\n    const formats = []\n    if (this.html) {\n      formats.push('html')\n    }\n    if (this.markdown) {\n      formats.push('markdown')\n    }\n    if (this.svg) {\n      formats.push('svg')\n    }\n    if (this.png) {\n      formats.push('png')\n    }\n    if (this.jpeg) {\n      formats.push('jpeg')\n    }\n    if (this.pdf) {\n      formats.push('pdf')\n    }\n    if (this.latex) {\n      formats.push('latex')\n    }\n    if (this.json) {\n      formats.push('json')\n    }\n    if (this.javascript) {\n      formats.push('javascript')\n    }\n    if (this.data) {\n      formats.push('data')\n    }\n\n    for (const key of Object.keys(this.extra)) {\n      formats.push(key)\n    }\n\n    return formats\n  }\n\n  /**\n   * Returns the serializable representation of the result.\n   */\n  toJSON() {\n    return {\n      text: this.text,\n      html: this.html,\n      markdown: this.markdown,\n      svg: this.svg,\n      png: this.png,\n      jpeg: this.jpeg,\n      pdf: this.pdf,\n      latex: this.latex,\n      json: this.json,\n      javascript: this.javascript,\n      ...(Object.keys(this.extra).length > 0 ? { extra: this.extra } : {}),\n    }\n  }\n}\n\n/**\n * Data printed to stdout and stderr during execution, usually by print statements, logs, warnings, subprocesses, etc.\n */\nexport type Logs = {\n  /**\n   * List of strings printed to stdout by prints, subprocesses, etc.\n   */\n  stdout: string[]\n  /**\n   * List of strings printed to stderr by prints, subprocesses, etc.\n   */\n  stderr: string[]\n}\n\n/**\n * Represents the result of a cell execution.\n */\nexport class Execution {\n  constructor(\n    /**\n     * List of result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots).\n     */\n    public results: Result[] = [],\n    /**\n     * Logs printed to stdout and stderr during execution.\n     */\n    public logs: Logs = { stdout: [], stderr: [] },\n    /**\n     * An Error object if an error occurred, null otherwise.\n     */\n    public error?: ExecutionError,\n    /**\n     * Execution count of the cell.\n     */\n    public executionCount?: number\n  ) { }\n\n  /**\n   * Returns the text representation of the main result of the cell.\n   */\n  get text(): string | undefined {\n    for (const data of this.results) {\n      if (data.isMainResult) {\n        return data.text\n      }\n    }\n  }\n\n  /**\n   * Returns the serializable representation of the execution result.\n   */\n  toJSON() {\n    return {\n      results: this.results,\n      logs: this.logs,\n      error: this.error,\n    }\n  }\n}\n\nexport async function parseOutput(\n  execution: Execution,\n  line: string,\n  onStdout?: (output: OutputMessage) => Promise<any> | any,\n  onStderr?: (output: OutputMessage) => Promise<any> | any,\n  onResult?: (data: Result) => Promise<any> | any,\n  onError?: (error: ExecutionError) => Promise<any> | any\n) {\n  const msg = JSON.parse(line)\n\n  switch (msg.type) {\n    case 'result':\n      const result = new Result(\n        { ...msg, type: undefined, is_main_result: undefined },\n        msg.is_main_result\n      )\n      execution.results.push(result)\n      if (onResult) {\n        await onResult(result)\n      }\n      break\n    case 'stdout':\n      execution.logs.stdout.push(msg.text)\n      if (onStdout) {\n        await onStdout({\n          error: false,\n          line: msg.text,\n          timestamp: new Date().getTime() * 1000,\n        })\n      }\n      break\n    case 'stderr':\n      execution.logs.stderr.push(msg.text)\n      if (onStderr) {\n        await onStderr({\n          error: true,\n          line: msg.text,\n          timestamp: new Date().getTime() * 1000,\n        })\n      }\n      break\n    case 'error':\n      execution.error = new ExecutionError(msg.name, msg.value, msg.traceback)\n      if (onError) {\n        await onError(execution.error)\n      }\n      break\n    case 'number_of_executions':\n      execution.executionCount = msg.execution_count\n      break\n  }\n}\n","import { TimeoutError } from 'e2b'\n\nexport function formatRequestTimeoutError(error: unknown) {\n  if (error instanceof Error && error.name === 'AbortError') {\n    return new TimeoutError('Request timed out — the \\'requestTimeoutMs\\' option can be used to increase this timeout')\n  }\n\n  return error\n}\n\nexport function formatExecutionTimeoutError(error: unknown) {\n  if (error instanceof Error && error.name === 'AbortError') {\n    return new TimeoutError('Execution timed out — the \\'timeoutMs\\' option can be used to increase this timeout')\n  }\n\n  return error\n}\n\nexport async function* readLines(stream: ReadableStream<Uint8Array>) {\n  const reader = stream.getReader();\n  let buffer = ''\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (value !== undefined) {\n        buffer += new TextDecoder().decode(value)\n      }\n\n      if (done) {\n        if (buffer.length > 0) {\n          yield buffer\n        }\n        break\n      }\n\n      let newlineIdx = -1\n\n      do {\n        newlineIdx = buffer.indexOf('\\n')\n        if (newlineIdx !== -1) {\n          yield buffer.slice(0, newlineIdx)\n          buffer = buffer.slice(newlineIdx + 1)\n        }\n      } while (newlineIdx !== -1)\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n","export const DEFAULT_TIMEOUT_MS = 60_000 // 1 minute\nexport const JUPYTER_PORT = 49999\n"],"mappings":"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","names":["TimeoutError","TimeoutError","error"]}